/*
vts_parsing: rust parser for the VTS and VTM (including others) files generated by VTOL VR.
Copyright (C) 2024 BlockListed

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
use std::iter::repeat;
use std::fmt::Write;

use crate::{parse::{Float, Map}, Value};

pub fn unparse(v: &Value) -> String {
    assert!(matches!(v, Value::Object(_)), "top level should be object");
    let v = match v {
        Value::Object(v) => v,
        _ => unreachable!(),
    };

    let mut s = String::new();

    for (k, v) in v {
        assert!(
            matches!(v, Value::Object(_)),
            "top level children should be objects"
        );
        let v = match v {
            Value::Object(v) => v,
            _ => unreachable!(),
        };

        unparse_object(0, &k.0, v, &mut s);
    }

    s
}

fn indent(depth: u32, output: &mut String) {
    (0..depth).for_each(|_| {
        output.write_char('\t').unwrap();
    });
}

// number, float, bool, tuple or null
fn unparse_value(v: &Value, output: &mut String) -> Option<()> {
    match v {
        Value::Number(v) => {
            output.write_fmt(format_args!("{}", v)).unwrap();

            Some(())
        }
        Value::Float(v) => {
            unparse_float(v, output);

            Some(())
        }
        Value::Boolean(v) => {
            if *v {
                output.write_str("True").unwrap();
            } else {
                output.write_str("False").unwrap();
            }

            Some(())
        }
        Value::Tuple(v) => {
            unparse_tuple(v, output);

            Some(())
        }
        Value::Null => Some(()),
        Value::String(v) => {
            output.write_str(v).unwrap();

            Some(())
        }
        _ => None,
    }
}

fn unparse_float(v: &Float, output: &mut String) {
    let Float(v, original) = v;
    if original
        .parse::<f64>()
        .ok()
        .is_some_and(|parsed| parsed.eq(v))
    {
        output.write_str(original).unwrap();
    } else {
        output.write_fmt(format_args!("{}", v)).unwrap();
    }
}

fn unparse_object(indent_depth: u32, k: &str, v: &Map, output: &mut String) {
    indent(indent_depth, output);
    output.write_str(k).unwrap();
    output.write_char('\n').unwrap();
    indent(indent_depth, output);
    output.write_char('{').unwrap();
    output.write_char('\n').unwrap();
    for (k, v) in v.iter() {
        match v {
            Value::Float(_) | Value::Number(_) | Value::String(_) | Value::Boolean(_) | Value::Tuple(_) | Value::Null => {
                indent(indent_depth+1, output);

                output.write_str(&k.0).unwrap();
                output.write_str(" = ").unwrap();

                unparse_value(v, output);
                output.write_char('\n').unwrap();
            },
            Value::Object(v) => unparse_object(indent_depth + 1, &k.0, v, output),
        }
    }
    indent(indent_depth, output);
    output.write_str("}\n").unwrap();
}

fn unparse_tuple(v: &[Value], output: &mut String) {
    output.write_char('(').unwrap();
    match v.split_last() {
        Some((last, rest)) => {
            for v in rest {
                unparse_value(v, output);
                output.write_str(", ").unwrap();
            }
            unparse_value(last, output);
        }
        None => (),
    }

    output.write_char(')').unwrap();
}
