/*
vts_parsing: rust parser for the VTS and VTM (including others) files generated by VTOL VR.
Copyright (C) 2024 BlockListed

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
use std::fmt::{Display, Formatter, Write};

use crate::{parse::{Float, Node}, Value};

pub fn unparse(v: &Node) -> String {
    let mut s = String::new();
    
    unparse_node(v, 0, &mut s);

    s
}

struct UnparseValue<'a>(&'a Value);

impl<'a> Display for UnparseValue<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.0 {
            Value::Number(v) => {
                f.write_fmt(format_args!("{}", v))?;
            }
            Value::Float(ref v) => {
                unparse_float(v, f)?;
            }
            Value::Boolean(v) => {
                if *v {
                    f.write_str("True")?;
                } else {
                    f.write_str("False")?;
                }
            }
            Value::Tuple(ref v) => {
                unparse_tuple(v, f)?;
            }
            Value::Null => (),
            Value::String(v) => {
                f.write_str(v)?;
            }
        };

        Ok(())
    }
}

fn unparse_float(v: &Float, f: &mut Formatter) -> std::fmt::Result {
    let Float(v, original) = v;
    if original
        .parse::<f64>()
        .ok()
        .is_some_and(|parsed| parsed.eq(v))
    {
        f.write_str(original)?;
    } else {
        f.write_fmt(format_args!("{}", v))?;
    }

    Ok(())
}

fn unparse_tuple(v: &[Value], f: &mut Formatter) -> std::fmt::Result {
    f.write_char('(')?;
    match v.split_last() {
        Some((last, rest)) => {
            for v in rest {
                UnparseValue(v).fmt(f)?;
                f.write_str(", ").unwrap();
            }
            UnparseValue(last).fmt(f)?;
        }
        None => (),
    }

    f.write_char(')')?;

    Ok(())
}

fn indent(depth: u32, output: &mut String) {
    (0..depth).for_each(|_| {
        output.write_char('\t').unwrap();
    });
}

fn unparse_node(node: &Node, indent_depth: u32, output: &mut String) {
    indent(indent_depth, output);
    output.write_str(&node.name).unwrap();
    output.write_char('\n').unwrap();
    indent(indent_depth, output);
    output.write_str("{\n").unwrap();
    for (k, v) in node.values.iter() {
        indent(indent_depth+1, output);
        output.write_fmt(format_args!("{} = {}\n", k, UnparseValue(v))).unwrap();
    }
    for n in node.nodes() {
        unparse_node(n, indent_depth+1, output);
    }
    indent(indent_depth, output);
    output.write_str("}\n").unwrap();
}
