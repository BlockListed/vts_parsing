/*
vts_parsing: rust parser for the VTS and VTM (including others) files generated by VTOL VR.
Copyright (C) 2024 BlockListed

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
use std::num::ParseFloatError;

use indexmap::IndexMap;
use nom::bytes::complete::tag;
use nom::bytes::complete::take_until;
use nom::bytes::complete::take_while1;
use nom::character::complete::multispace0;
use nom::character::complete::multispace1;
use nom::character::complete::space0;
use nom::combinator::map_res;
use nom::error::context;
use nom::error::make_error;
use nom::multi::many0;
use nom::multi::separated_list1;
use nom::number::streaming::recognize_float;
use nom::sequence::delimited;
use nom::sequence::preceded;
use nom::sequence::separated_pair;
use nom::sequence::terminated;
use nom::sequence::tuple;
use nom::AsChar;
use nom::IResult;
use nom::Parser;

#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Number(i64),
    /// This also includes the original formatting of the float, so that we change the file as
    /// little as possible. You don't need to worry about that though.
    Float(Float),
    Boolean(bool),
    Vector([Float; 3]),
    String(String),
    Null,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Node {
    pub name: String,
    pub values: IndexMap<String, Value>,
    pub nodes: Vec<Node>,
}

impl Node {
    pub fn new(name: String, values: IndexMap<String, Value>, nodes: Vec<Node>) -> Node {
        Node {
            name,
            values,
            nodes,
        }
    }

    pub fn nodes(&self) -> impl Iterator<Item = &Node> {
        self.nodes.iter()
    }

    pub fn nodes_mut(&mut self) -> impl Iterator<Item = &mut Node> {
        self.nodes.iter_mut()
    }

    pub fn get_node(&self, k: &str) -> Option<&Node> {
        self.nodes().find(|n| n.name == k)
    }

    pub fn get_node_mut(&mut self, k: &str) -> Option<&mut Node> {
        self.nodes_mut().find(|n| n.name == k)
    }
}

#[derive(Debug, Clone)]
/// This also includes the original formatting.
/// If modified, this will automatically serialize the new value, instead of the saved original.
/// Basically just treat this as a float.
pub struct Float(pub f64, pub(crate) String);

impl Float {
    pub fn new(v: f64) -> Float {
        Float(v, String::new())
    }
}

impl PartialEq for Float {
    fn eq(&self, other: &Self) -> bool {
        self.0.eq(&other.0)
    }
}

pub fn parse(vts: &str) -> Node {
    parse_node(vts).unwrap().1
}

fn parse_node(vts: &str) -> IResult<&str, Node> {
    let (vts, title) = terminated(
        take_while1(|c: char| c.is_alphanum() || c == '_'),
        multispace0,
    )(vts)?;

    let fields_parser = many0(delimited(
        space0,
        parse_node_value.map(|(t, v)| (t.to_owned(), v)),
        multispace1,
    ));

    let nodes_parser = many0(delimited(multispace0, parse_node, multispace0));

    let (vts, (values, nodes)) = delimited(
        tuple((tag("{"), multispace0)),
        tuple((fields_parser, nodes_parser)),
        preceded(multispace0, tag("}")),
    )(vts)?;

    Ok((
        vts,
        Node {
            name: title.to_string(),
            values: values.into_iter().collect(),
            nodes,
        },
    ))
}

fn parse_value(vts: &str) -> IResult<&str, Value> {
    // number first
    Ok(vts
        .parse::<i64>()
        .ok()
        .map(Value::Number)
        // float
        .or_else(|| {
            vts.parse::<f64>()
                .map(|v| Value::Float(Float(v, vts.to_owned())))
                .ok()
        })
        // boolean
        .or(match vts {
            "True" => Some(Value::Boolean(true)),
            "False" => Some(Value::Boolean(false)),
            _ => None,
        })
        .map(|v| ("", v))
        // tuple
        .or_else(|| parse_vector.map(Value::Vector).parse(vts).ok())
        .or_else(|| {
            if vts.is_empty() {
                return Some(("", Value::Null));
            }

            None
        })
        // string
        .unwrap_or_else(|| ("", Value::String(vts.to_owned()))))
}

fn parse_vector(vts: &str) -> IResult<&str, [Float; 3]> {
    let (should_be_empty, v) = delimited(
        tag("("),
        separated_list1(
            tuple((tag(","), space0)),
            map_res(recognize_float, |f: &str| {
                Ok::<_, ParseFloatError>(Float(f.parse::<f64>()?, f.to_string()))
            }),
        ),
        tag(")"),
    )(vts)?;

    if !should_be_empty.is_empty() {
        return Err(nom::Err::Error(make_error(
            vts,
            nom::error::ErrorKind::NonEmpty,
        )));
    }

    if v.len() != 3 {
        return Err(nom::Err::Error(make_error(
            vts,
            nom::error::ErrorKind::Count,
        )));
    }

    let mut i = v.into_iter();

    Ok((
        should_be_empty,
        [i.next().unwrap(), i.next().unwrap(), i.next().unwrap()],
    ))
}

fn parse_node_value(vts: &str) -> IResult<&str, (&str, Value)> {
    separated_pair(
        take_while1(|c: char| c.is_alphanum() || c == '_'),
        tuple((space0, context("expected equals while parsing value", tag("=")), space0)),
        take_until("\r\n").or(take_until("\n")).and_then(parse_value),
    )(vts)
}

#[cfg(test)]
mod testing {
    use super::parse;
    use super::parse_vector;
    use super::Float;

    const TEST_STR: &str = include_str!("../amogus testing.vts");

    const SAM_EVASION_PARSE: &str = include_str!("../SAM Missile Evasion Practice.vts");

    #[test]
    fn test_parse() {
        eprintln!("{:#?}", parse(TEST_STR));
    }

    #[test]
    fn sam_evasion_parse() {
        eprintln!("{:#?}", parse(SAM_EVASION_PARSE));
    }

    #[test]
    fn test_tuple() {
        assert_eq!(
            parse_vector("(-234.3, 5, 403.3)"),
            Ok((
                "",
                [
                    Float(-234.3, "-234.3".into()),
                    Float(5.0, "5".into()),
                    Float(403.3, "403.3".into()),
                ]
            ))
        );
    }

    #[test]
    fn test_tuple_no_parse() {
        let vts = "(5.0, 5.0, 5.0);(5.0, 5.0, 5.0);";
        assert_eq!(
            parse_vector(vts),
            Err(nom::Err::Error(nom::error::make_error(
                vts,
                nom::error::ErrorKind::NonEmpty
            ))),
        );
    }
}
